这篇文章比较有意思了，将介绍滤镜的实现原理。滤镜功能广泛应用
于相机、图库、短视频等应用，如抖音，看一下抖音的滤镜功能

![抖音滤镜](https://upload-images.jianshu.io/upload_images/11562793-edc6858e50d033d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/100)

可以看到，抖音提供了很多不同的滤镜。无意间看到这篇文章
[当一个 Android 开发玩抖音玩疯了之后(二)]([https://www.jianshu.com/p/5bb7f2a0da90](https://www.jianshu.com/p/5bb7f2a0da90)
)里面提供了5中抖音滤镜实现，大家可以看一下，不过因为还没涉及动画和相机预览，所以这一节我们就拿一张静态图片来实现滤镜功能。

我们最终要实现的效果：
[图片]




继续阅读本文，需要您对OpenGL有一定了解，
如果对OpenGL不熟悉，请先阅读以下文章：
[《OpenGL从入门到放弃01 》一些基本概念](https://www.jianshu.com/p/1e150df8c26a)
[《OpenGL从入门到放弃02 》GLSurfaceView和Renderer](https://www.jianshu.com/p/632233a6c0c5)
[《OpenGL从入门到放弃03 》相机和视图](https://www.jianshu.com/p/0efcd0d1eb5b)
[《OpenGL从入门到放弃04 》画一个长方形](https://www.jianshu.com/p/e75e03ab135b)
[《OpenGL从入门到放弃05 》着色器语言](https://www.jianshu.com/p/be587cedcc2e)
[《OpenGL从入门到放弃06 》纹理图片显示](https://www.jianshu.com/p/9e10c8230022)

---

## 简单色彩处理

在OpenGL中，颜色是用包含四个浮点的向量vec4表示，四个浮点分别表示RGBA四个通道，取值范围为0.0-1.0。
**我们先读取图片每个像素的色彩值，再对读取到的色彩值进行调整，这样就可以完成对图片的色彩处理了。**

我们应该都知道，**黑白图片上，每个像素点的RGB三个通道值应该是相等的**。知道了这个，将彩色图片处理成黑白图片就非常简单了。
我们直接取出像素点的RGB三个通道，相加然后除以3作为处理后每个通道的值就可以得到一个黑白图片了。这是均值的方式是常见黑白图片处理的一种方法。
类似的还有权值方法（给予RGB三个通道不同的比例）、只取绿色通道等方式。

与之类似的，
**冷色调**的处理就是单一增加蓝色通道的值，
**暖色调**的处理可以增加红绿通道的值。
还有其他复古、浮雕等处理也都差不多。

## 图片模糊处理
**图片模糊处理**相对上面的色调处理稍微复杂一点，通常图片模糊处理是采集周边多个点，然后利用这些点的色彩和这个点自身的色彩进行计算，
得到一个新的色彩值作为目标色彩。模糊处理有很多算法，类似高斯模糊、径向模糊等等。

## 放大镜效果
**放大镜效果**相对模糊处理来说，处理过程也会相对简单一些。我们只需要将制定区域的像素点，都以需要放大的区域中心点为中心，
向外延伸其到这个中心的距离即可实现放大效果。具体实现，可参考着色器中vChangeType=4时的操作。

## 四分镜效果
把整张图片缩成四份，然后分别放在左上角、右上角、左下角、右下角等地方。我们可以通过改变UV坐标得到

---
啰嗦那么多，show me the code ?
[图片]

## 实战

### 一、修改着色器


由于这次要大改着色器，所以把着色器代码放到一个单独的文件，放在assets目录下，

【图片】


后缀改为glsl，然后安装as插件**GLSL SUPPORT**，打开即可看到语法高亮，还可以跳转方法。

【图片】

顶点着色器：shader/filter/filter_vertex.glsl

```
uniform mat4 uMVPMatrix;//接收传入的转换矩阵
attribute vec4 vPosition;//接收传入的顶点
attribute vec2 aTexCoord;//接收传入的顶点纹理位置
varying vec2 vTextureCoord;//增加用于传递给片元着色器的纹理位置变量
varying vec4 gPosition;//传顶点坐标给片元着色器
void main() {
    gl_Position = uMVPMatrix * vPosition;//矩阵变换计算之后的位置
    gPosition = uMVPMatrix * vPosition;//矩阵变换计算之后的位置
    vTextureCoord = aTexCoord;
}
```

定义要传递给片元着色器的变量：
vTextureCoord（纹理坐标）
gPosition （顶点坐标）
然后赋值


重点在片元着色器的处理：shader/filter/filter_fragment.glsl

```
precision mediump float;// 声明float类型的精度为中等(精度越高越耗资源)
varying vec2 vTextureCoord;//顶点着色器传过来的纹理坐标向量
uniform sampler2D vTexture;//纹理采样器，代表一副纹理

uniform int vChangeType;//【应用需要传类型过来，对不同类型做不同处理】
uniform vec3 vChangeColor;

uniform float uXY;//屏幕宽高比
varying vec4 gPosition; //顶点着色器把坐标传过来

void modifyColor(vec4 color){
    color.r=max(min(color.r, 1.0), 0.0);
    color.g=max(min(color.g, 1.0), 0.0);
    color.b=max(min(color.b, 1.0), 0.0);
    color.a=max(min(color.a, 1.0), 0.0);
}

void main() {
    vec4 nColor = texture2D(vTexture, vTextureCoord);//进行纹理采样,拿到当前颜色
    if (vChangeType==1){ //黑白处理，两种方式都可以
//        float c=nColor.r*vChangeColor.r+nColor.g*vChangeColor.g+nColor.b*vChangeColor.b;
//        gl_FragColor=vec4(c, c, c, nColor.a);
        float c=(nColor.r + nColor.g + nColor.b)/3.0;
        gl_FragColor=vec4(c, c, c, nColor.a);
    } else if (vChangeType==2){ //简单色彩处理，冷暖色调、增加亮度、降低亮度等
        //颜色相加，冷就是多加点蓝，暖就是多加点红跟绿
        vec4 deltaColor=nColor + vec4(vChangeColor, 0.0);
//        modifyColor(deltaColor);
        gl_FragColor=deltaColor;
    } else if (vChangeType==3){ //模糊处理，取与当前颜色相近的周边12个点的颜色，加上本身的颜色，取平均值
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x-vChangeColor.r, vTextureCoord.y-vChangeColor.r));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x-vChangeColor.r, vTextureCoord.y+vChangeColor.r));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x+vChangeColor.r, vTextureCoord.y-vChangeColor.r));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x+vChangeColor.r, vTextureCoord.y+vChangeColor.r));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x-vChangeColor.g, vTextureCoord.y-vChangeColor.g));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x-vChangeColor.g, vTextureCoord.y+vChangeColor.g));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x+vChangeColor.g, vTextureCoord.y-vChangeColor.g));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x+vChangeColor.g, vTextureCoord.y+vChangeColor.g));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x-vChangeColor.b, vTextureCoord.y-vChangeColor.b));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x-vChangeColor.b, vTextureCoord.y+vChangeColor.b));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x+vChangeColor.b, vTextureCoord.y-vChangeColor.b));
        nColor+=texture2D(vTexture, vec2(vTextureCoord.x+vChangeColor.b, vTextureCoord.y+vChangeColor.b));
        nColor/=13.0;
        gl_FragColor=nColor;
    } else if (vChangeType==4){ //放大镜效果,
        //到中心点距离
        float dis=distance(vec2(gPosition.x, gPosition.y), vec2(0, 0));
        //距离在这个区块内放大，改变纹理坐标，为什么+0.25？
        if (dis<vChangeColor.b){
            nColor=texture2D(vTexture, vec2(vTextureCoord.x/2.0+0.25, vTextureCoord.y/2.0+0.25));
        }
        gl_FragColor=nColor;
    } else if (vChangeType==5){ //四分镜就是把整张图片缩成四份，然后分别放在左上角、右上角、左下角、右下角等地方。我们可以通过改变纹理坐标得到
        vec2 uv = vTextureCoord;
        if (uv.x <= 0.5) {
            uv.x = uv.x * 2.0;
        } else {
            uv.x = (uv.x - 0.5) * 2.0;
        }
        if (uv.y <= 0.5) {
            uv.y = uv.y * 2.0;
        } else {
            uv.y = (uv.y - 0.5) * 2.0;
        }
        gl_FragColor = texture2D(vTexture, fract(uv));//fract(x): 取小数部分
    } else {
        gl_FragColor=nColor;//不处理
    }
}
```

变量的命名比较随意了...


片元着色器增加了两个变量需要应用传递过去，vChangeType和vChangeColor，
然后根据类型做不同的滤镜处理，黑白、冷色调、模糊、放大。

为了方便，定义一个滤镜的枚举 

```
    public enum Filter{
        NONE(0,new float[]{0.0f,0.0f,0.0f}),    //默认
        GRAY(1,new float[]{0.299f,0.587f,0.114f}),
        COOL(2,new float[]{0.0f,0.0f,0.1f}),
        WARM(2,new float[]{0.1f,0.1f,0.0f}),
        BLUR(3,new float[]{0.006f,0.004f,0.002f}),
        MAGN(4,new float[]{0.0f,0.0f,0.4f}),
        FOUR(5,new float[]{0.0f,0.0f,0.0f}); //四分镜

        private int vChangeType;
        private float[] data;

        Filter(int vChangeType,float[] data){
            this.vChangeType=vChangeType;
            this.data=data;
        }

        public int getType(){
            return vChangeType;
        }

        public float[] data(){
            return data;
        }

    }
```

