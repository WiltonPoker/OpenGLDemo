[参考](https://www.jianshu.com/p/92d02ac80611)

续上一节。

# 投影和相机视图

通常情况下，OpenGl中展示的视图和在Android上显示的图形会有偏差。借用官方图片


<img src="https://upload-images.jianshu.io/upload_images/3965704-188412969a9a1f19?imageMogr2/auto-orient/strip%7CimageView2/2/w/898/format/webp" width="30%" height="50%"> 



当然我们可以通过矩阵转换来解决这种问题，让OpenGl上的视图在任何android设备上显示的比例都是一样的，这里就要用到**投影**和**相机视图**


## 投影
使用OpenGl绘制的3D图形，需要展示在移动端2D设备上，这就需要投影
OpenGl ES中有两种投影方式：一种是**正交投影**，一种是**透视投影**：

### 正交投影（camera中用到）
投影物体的大小不会随观察点的远近而发生变化，我们可以使用下面方法来执行正交投影

    Matrix.orthoM (float[] m,           //接收正交投影的变换矩阵
                int mOffset,        //变换矩阵的起始位置（偏移量）
                float left,         //相对观察点近面的左边距
                float right,        //相对观察点近面的右边距
                float bottom,       //相对观察点近面的下边距
                float top,          //相对观察点近面的上边距
                float near,         //相对观察点近面距离
                float far)          //相对观察点远面距离

### 透视投影
随观察点的距离变化而变化，观察点越远，视图越小，反之越大，我们可以通过如下方法来设置透视投影：

    Matrix.frustumM (float[] m,         //接收透视投影的变换矩阵
                int mOffset,        //变换矩阵的起始位置（偏移量）
                float left,         //相对观察点近面的左边距
                float right,        //相对观察点近面的右边距
                float bottom,       //相对观察点近面的下边距
                float top,          //相对观察点近面的上边距
                float near,         //相对观察点近面距离
                float far)          //相对观察点远面距离

## 相机视图


什么是相机视图？简单来说生活中我们拍照，你站的高度，拿相机的位置，姿势不同，拍出来的照片也就不一样，**相机视图就是来修改相机位置，观察方式以及相机的倾斜角度等属性**。我们可以通过下面方法来修改相机视图属性：

    Matrix.setLookAtM (float[] rm,      //接收相机变换矩阵
                int rmOffset,       //变换矩阵的起始位置（偏移量）
                float eyeX,float eyeY, float eyeZ,   //相机位置
                float centerX,float centerY,float centerZ,  //观察点位置
                float upX,float upY,float upZ)  //up向量在xyz上的分量

## 转换矩阵（变换矩阵）

转换矩阵用来做什么的呢？  
是否记得上面我们绘制的图形坐标需要转换为OpenGl中能处理的小端字节序（LittleEdian） 
没错，**转换矩阵就是用来将数据转为OpenGl ES可用的数据字节**，我们将相机视图和投影设置的数据相乘，便得到一个转换矩阵，然后我们再将此矩阵传给顶点着色器，具体使用方法及参数说明如下：

    Matrix.multiplyMM (float[] result, //接收相乘结果
                int resultOffset,  //接收矩阵的起始位置（偏移量）
                float[] lhs,       //左矩阵
                int lhsOffset,     //左矩阵的起始位置（偏移量）
                float[] rhs,       //右矩阵
                int rhsOffset)     //右矩阵的起始位置（偏移量）


下面简单讲解下如何使用投影和相机视图来实现矩阵变换并传递给顶点着色器

## 实战
### 1、定义一个投影

    // mMVPMatrix 是"Model View Projection Matrix"（模型视图投影矩阵） 缩写
    private final float[] mMVPMatrix = new float[16];
	private final float[] mProjectionMatrix = new float[16];
    private final float[] mViewMatrix = new float[16];

    public void onSurfaceChanged(GL10 unused, int width, int height) {
        GLES20.glViewport(0, 0, width, height);

        float ratio = (float) width / height;

        // 这个投影矩阵被应用于对象坐标在onDrawFrame（）方法中
        Matrix.frustumM(mProjectionMatrix, 0, -ratio, ratio, -1, 1, 3, 7);
    }

### 2、定义一个相机视图

    @Override
	public void onDrawFrame(GL10 unused) {
	    ...
	    // 设置相机位置(View matrix)
	    Matrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
	
	    // 转换矩阵
	    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);
	
	    // Draw shape
	    mTriangle.draw(mMVPMatrix);
	}

### 3、修改顶点着色器代码
    
	public class Triangle {

    private final String vertexShaderCode =
        // This matrix member variable provides a hook to manipulate
        // the coordinates of the objects that use this vertex shader
        "uniform mat4 uMVPMatrix;" +
        "attribute vec4 vPosition;" +
        "void main() {" +
        // the matrix must be included as a modifier of gl_Position
        // Note that the uMVPMatrix factor *must be first* in order
        // for the matrix multiplication product to be correct.
        "  gl_Position = uMVPMatrix * vPosition;" +
        "}";

    // Use to access and set the view transformation
    private int mMVPMatrixHandle;

    ...
}

### 4、投影和相机视图代码到图形类的绘制方法中去onDraw()
    public void draw(float[] mvpMatrix){
       ... ...
        // 得到形状的变换矩阵的句柄
        mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix");

        // 将投影和视图转换传递给着色器
        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);

        // 画三角形
        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);

        // 禁用顶点数组
        GLES20.glDisableVertexAttribArray(mPositionHandle);
    }


没错，这才没有变形的视图。到这里，基本的通过OpenGl绘制简单图形就over了


说一下矩阵：

    private final float[] mMVPMatrix = new float[16];
	m[0]=0f;
	m[1]=0f;
	m[2]=0f;
	m[3]=0f;

把矩阵数据存到了浮点数组中，这个数组需要至少16个元素。OpenGL把矩阵数据按照以列为主的顺序存储，这就意味着我们一次写一列数据，而不是一次写一行。前四个值是第一列，下一组四个数是第二列，以此类推。


Matrix.translateM(modelMatrix,0,0f,0f,-2.5f);

Matrix.rotateM(modelMatrix,0,-60f,1f,0f,0f);





[可以参考这篇](https://www.cnblogs.com/liyuanjinglyj/p/4656545.html)